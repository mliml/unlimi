from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session as DBSession
from sqlalchemy import func, desc
from typing import List
from app.db.database import get_db
from app.core.deps import get_current_user
from app.db.models.user import User
from app.db.models.session import Session, SessionStatus
from app.db.models.session_message import SessionMessage, MessageSender
from app.schemas.session_action import SessionStartResponse, SessionEndResponse, ActiveSessionResponse
from app.schemas.session_message import SessionMessageRequest, SessionMessageResponse, SessionMessageListItem
from app.schemas.session import SessionDetail, SessionHistoryItem
from app.services.llm_service import LLMService
from app.orchestrator.session_orchestrator import SessionOrchestrator

router = APIRouter(prefix="/sessions", tags=["sessions"])


@router.get("/active", response_model=ActiveSessionResponse)
def get_active_session(
    current_user: User = Depends(get_current_user),
    db: DBSession = Depends(get_db)
):
    """
    Check if current user has an active (open) session.

    This endpoint queries the sessions table for the most recent session
    with status='open' for the current user.

    Args:
        current_user: Authenticated user
        db: Database session

    Returns:
        ActiveSessionResponse with:
        - active: True if an open session exists, False otherwise
        - session_id: ID of the active session if exists, None otherwise
    """
    # Query for the most recent open session
    active_session = db.query(Session).filter(
        Session.user_id == current_user.id,
        Session.status == SessionStatus.open
    ).order_by(
        desc(Session.start_time)
    ).first()

    if active_session:
        return ActiveSessionResponse(
            active=True,
            session_id=active_session.id
        )
    else:
        return ActiveSessionResponse(
            active=False,
            session_id=None
        )


@router.get("/history", response_model=List[SessionHistoryItem])
def get_history_sessions(
    current_user: User = Depends(get_current_user),
    db: DBSession = Depends(get_db)
):
    """
    Get list of all closed sessions for the current user.

    This endpoint returns:
    - Session ID
    - Start time
    - End time
    - Message count
    - Index (consultation number)

    Sessions are ordered by start_time ascending (oldest first).

    Args:
        current_user: Authenticated user
        db: Database session

    Returns:
        List of SessionHistoryItem objects
    """
    # Query closed sessions with message count
    sessions = db.query(
        Session.id,
        Session.start_time,
        Session.end_time,
        func.count(SessionMessage.id).label("message_count")
    ).outerjoin(
        SessionMessage, Session.id == SessionMessage.session_id
    ).filter(
        Session.user_id == current_user.id,
        Session.status == SessionStatus.closed
    ).group_by(
        Session.id
    ).order_by(
        Session.start_time.asc()
    ).all()

    # Build response with index
    result = []
    for idx, (session_id, start_time, end_time, message_count) in enumerate(sessions, start=1):
        result.append(SessionHistoryItem(
            id=session_id,
            start_time=start_time,
            end_time=end_time,
            message_count=message_count,
            index=idx
        ))

    return result


@router.get("/{session_id}", response_model=SessionDetail)
def get_session_detail(
    session_id: int,
    current_user: User = Depends(get_current_user),
    db: DBSession = Depends(get_db)
):
    """
    Get detailed information about a specific session.

    This endpoint returns:
    - Session ID
    - Start time
    - End time
    - Is closed status
    - Message count
    - First message text
    - Last message text

    Args:
        session_id: ID of the session to retrieve
        current_user: Authenticated user
        db: Database session

    Returns:
        SessionDetail object

    Raises:
        HTTPException 404: If session not found
        HTTPException 403: If session doesn't belong to user
    """
    # Validate session exists and belongs to user
    session = db.query(Session).filter(Session.id == session_id).first()
    if not session:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Session {session_id} not found"
        )

    if session.user_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You don't have permission to access this session"
        )

    # Get message count
    message_count = db.query(func.count(SessionMessage.id)).filter(
        SessionMessage.session_id == session_id
    ).scalar() or 0

    return SessionDetail(
        id=session.id,
        start_time=session.start_time,
        end_time=session.end_time,
        is_closed=(session.status == SessionStatus.closed),
        message_count=message_count,
        review_text=session.review.message_review if session.review else None,
        key_events=session.review.key_events if session.review else [],
        plan_text=None
    )


@router.post("/start", response_model=SessionStartResponse, status_code=status.HTTP_201_CREATED)
def start_session(
    current_user: User = Depends(get_current_user),
    db: DBSession = Depends(get_db)
):
    """
    Start a new therapy session.

    This endpoint:
    1. Creates a new session record in the database
    2. Sets status to 'open' and records start time
    3. Returns the session_id

    Args:
        current_user: Authenticated user
        db: Database session

    Returns:
        SessionStartResponse with session_id
    """
    try:
        # Create new session
        new_session = Session(
            user_id=current_user.id,
            status=SessionStatus.open
        )
        db.add(new_session)
        db.commit()
        db.refresh(new_session)

        return SessionStartResponse(session_id=new_session.id)

    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to start session: {str(e)}"
        )


@router.get("/{session_id}/get_messages", response_model=List[SessionMessageListItem])
def get_session_messages(
    session_id: int,
    current_user: User = Depends(get_current_user),
    db: DBSession = Depends(get_db)
):
    """
    Get all messages for a specific session.

    This endpoint:
    1. Validates the session exists
    2. Validates the session belongs to the current user
    3. Returns all messages ordered by created_at ascending

    Args:
        session_id: ID of the session
        current_user: Authenticated user
        db: Database session

    Returns:
        List of SessionMessageListItem objects ordered by created_at

    Raises:
        HTTPException 404: If session not found
        HTTPException 403: If session doesn't belong to user
    """
    # Step 1: Validate session exists
    session = db.query(Session).filter(Session.id == session_id).first()
    if not session:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Session {session_id} not found"
        )

    # Step 2: Validate session belongs to current user
    if session.user_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You don't have permission to access this session"
        )

    # Step 3: Query all messages ordered by created_at
    messages = db.query(SessionMessage).filter(
        SessionMessage.session_id == session_id
    ).order_by(
        SessionMessage.created_at.asc()
    ).all()

    # Convert to response schema
    return [
        SessionMessageListItem(
            id=msg.id,
            sender=msg.sender.value,
            message=msg.message,
            created_at=msg.created_at
        )
        for msg in messages
    ]


@router.post("/{session_id}/post_message", response_model=SessionMessageResponse)
def send_message(
    session_id: int,
    message_request: SessionMessageRequest,
    current_user: User = Depends(get_current_user),
    db: DBSession = Depends(get_db)
):
    """
    Send a message in a therapy session and get therapist's response.

    This endpoint:
    1. Validates the session exists and belongs to the user
    2. Saves user message to database
    3. Calls orchestrator to generate therapist response
    4. Saves therapist response to database
    5. Returns the response

    Args:
        session_id: ID of the session
        message_request: User's message
        current_user: Authenticated user
        db: Database session

    Returns:
        SessionMessageResponse with therapist's reply

    Raises:
        HTTPException 404: If session not found
        HTTPException 403: If session doesn't belong to user
        HTTPException 400: If session is closed
        HTTPException 500: If processing fails
    """
    try:
        # Step 1: Validate session
        session = db.query(Session).filter(Session.id == session_id).first()
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Session {session_id} not found"
            )

        if session.user_id != current_user.id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to access this session"
            )

        if session.status != SessionStatus.open:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Session is closed"
            )

        # Step 2: Save user message
        user_message = SessionMessage(
            session_id=session_id,
            sender=MessageSender.user,
            message=message_request.message
        )
        db.add(user_message)
        db.commit()

        # Step 3: Process message with orchestrator
        llm_service = LLMService()
        orchestrator = SessionOrchestrator(db=db, llm_service=llm_service)

        try:
            therapist_reply = orchestrator.process_message(
                user_id=current_user.id,
                session_id=session_id,
                user_message=message_request.message
            )
        except ValueError as e:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(e)
            )
        except Exception as e:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to generate response: {str(e)}"
            )

        # Step 4: Save therapist response
        therapist_message = SessionMessage(
            session_id=session_id,
            sender=MessageSender.therapist,
            message=therapist_reply
        )
        db.add(therapist_message)
        db.commit()

        # Step 5: Return response
        return SessionMessageResponse(reply=therapist_reply)

    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Unexpected error: {str(e)}"
        )


@router.post("/{session_id}/end", response_model=SessionEndResponse)
def end_session(
    session_id: int,
    current_user: User = Depends(get_current_user),
    db: DBSession = Depends(get_db)
):
    """
    End a therapy session and generate AI-powered summary.

    This endpoint:
    1. Validates the session exists and belongs to the user
    2. Loads all session messages
    3. Calls ClerkAgent to generate session review and key events
    4. Updates session status to 'closed'
    5. Records end time
    6. Saves review_text and key_events to database
    7. Returns the summary to frontend

    Args:
        session_id: ID of the session to end
        current_user: Authenticated user
        db: Database session

    Returns:
        SessionEndResponse with session_id, session_review, and key_events

    Raises:
        HTTPException 404: If session not found
        HTTPException 403: If session doesn't belong to user
        HTTPException 400: If session is already closed
        HTTPException 500: If processing fails
    """
    try:
        # Step 1: Validate session
        session = db.query(Session).filter(Session.id == session_id).first()
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Session {session_id} not found"
            )

        if session.user_id != current_user.id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to access this session"
            )

        if session.status == SessionStatus.closed:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Session is already closed"
            )

        # Step 2: Process session with ClerkAgent
        llm_service = LLMService()
        orchestrator = SessionOrchestrator(db=db, llm_service=llm_service)

        try:
            clerk_result = orchestrator.end_session_with_review(session_id)
        except Exception as e:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to generate session review: {str(e)}"
            )

        # Step 3: Update session status and create review
        session.status = SessionStatus.closed
        from datetime import datetime
        session.end_time = datetime.utcnow()

        # Create SessionReview
        from app.db.models.session_review import SessionReview
        review = SessionReview(
            session_id=session.id,
            message_review=clerk_result.session_review,
            key_events=clerk_result.key_events
        )
        db.add(review)

        db.commit()
        db.refresh(session)
        db.refresh(review)

        # Step 4: Return response
        return SessionEndResponse(
            session_id=session.id,
            session_review=review.message_review,
            key_events=review.key_events or []
        )

    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to end session: {str(e)}"
        )


